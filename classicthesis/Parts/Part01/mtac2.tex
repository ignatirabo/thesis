\chapter{Mtac2}\label{ch:mtac2}

\Mtac \cite{DBLP:journals/pacmpl/KaiserZKRD18} es un meta-lenguaje de programación para Coq. Esto quiere decir que complementa a Coq, permitiendo ``hacer Coq'' de una manera distinta. En el trabajo, nos centramos en ampliar \Mtac y por eso es importante que veamos que nos permite hacer y cómo.

\section{Meta-tácticas}

Ahora volveremos al ejemplo \ref{lst:sub_0_r} y utilizaremos tácticas de \Mtac para probarlo.

\graffito{TODO: explicar más}
\begin{lstlisting}[frame=tb,caption={Prueba en \Mtac},label=lst:sub_0_r_mtac2]
MProof.
intro n. case n &> [m: idtac | intro n'] &> reflexivity.
Qed.
\end{lstlisting}

\section{Mónadas}

\graffito{TODO: Beta pregunta porqué hablamos de mónadas}
Las mónadas son uno de los temas esotéricos de programación funcional y son una implementación del concepto de teoría de categorías.
% Según el libro X son ...
%TODO: citar el libro que me pasó miguel de teoría de categorías?
Por esto nos limitaremos a hablar de mónadas a un nivel más computacional. Dentro de este contexto, utilizamos la función \lstinline{M : Type -> Prop} para referirnos a la versión monádica de un tipo cualquiera. A partir de los tipos monádicos, pasamos a tener elementos monádicos. Estos elementos reflejan pasos computacionales y se construyen a través de dos funciones: \lstinline{bind} compone pasos computacionales y \lstinline{return} o \lstinline{ret} los envuelve en la mónada. Por ejemplo, podemos tener el tipo \lstinline{M nat} que expresa posibles valores naturales, y uno de estos elementos es \lstinline{ret 5}. Lo importante de las mónadas es que nos permiten expresar programas con efectos secundarios de una manera funcional.
\graffito{TODO: No nos interesan los detalles?}
Esto también es lo que nos permite tener tacticas tipadas, pero no nos interesan los detalles de la implementación.

\section{Confección de Meta-programas}

Ya habiendo mencionado meta-tácticas, tornaremos nuestra atención a meta-programas. Las meta-tácticas serán programas de \Mtac. Estos programas se caracterizan por ser monádicos, es decir, que tienen efectos secundarios. Esto se amplia a muchas caracteristicas útiles, pero nada es gratis, entonces debemos comprender las limitaciones impuestas por el meta-lenguaje.

% TODO: acá hablamos de mmatch, mtmmatch, mfix y las nuevas meta-cosas: sigmas, etc.
Comenzaremos analizando \lstinline{mmatch}. Como ya vimos en Gallina, el \lstinline{match} es puro, o sea, necesitamos matchear todos los casos del constructor y a su vez no podemos matchear en terminos que no sean constructores del tipo. Mientras tanto, \lstinline{mmatch} nos permite matchear libremente. Esto significa que podemos matchear en expresiones sintácticas de manera de separarlas muy especificamente para nuestra conveniencia. Un ejemplo puede ser el siguiente.

Imaginemos un programa que a todo número le suma uno, pero especificamente no modifica el número original si este está expresado como una suma. Esto se puede exprezar de la siguiente forma en \Mtac.
\begin{lstlisting}
Definition test_match (n : nat) : M nat :=
  mmatch n with
  | [? x y] add x y => ret n
  | O => ret (S O)
  | [? n'] S n' => ret (S (S n'))
  end.
\end{lstlisting}

El único detalle extraño que podemos encontrar es que en dos de los casos tenemos unos corchetes antes de la expresión. Esto se utiliza para decirle a \Mtac que estas variables están siendo introducidas al contexto.

% mfix
\graffito{TODO: agregar explicación de mfix y mtmmatch ya que los usamos}
Para hacer programas recursivos utilizaremos \lstinline{mfix}. Existen multiples variantes para una cantidad distinta de argumentos recursivos: \lstinline{mfix1}, \lstinline{mfix2}, e
tcetera.

Un ejemplo puede ser \lstinline{map}.
\begin{lstlisting}
Definition map {A} {B} (t : A -> B) : \forall (l : list A), M (list B) :=
mfix1 m (l : list A) : M list B :=
  mmatch l with
  | nil => ret nil
  | [? x xs] x::xs => xs' <- m xs;
                            ret ((t x)::xs')
  end.
\end{lstlisting}

En \lstinline{map} solo tenemos un argumento recursivo que será la lista que estamos mapeando.
En el ejemplo también vemos el uso de la notación \lstinline{<-}. Esta signfica que estamos \emph{bindeando} a la variable \lstinline{xs'} con el cómputo \lstinline{m xs}. En otros ejemplos es posible que veamos otra notación: \lstinline{;;}. Esta también es un bind pero con la diferencia de que no nos interesa el valor que retorna. Usualmente lo observaremos al usar \lstinline{print}, ya que esta función retorna \lstinline{unit}.

\section{El costo}

Como dijimos anteriormente, las funcionalidades de Mtac2 tienen un coste. Habiamos mencionado que un elemento monádico de tipo \lstinline{M nat} puede ser \lstinline{ret 5}. Pero imaginemos que estamos calculando el cociente entre dos números enteros y el divisor en 0. Entonces el programa no puede devolver el cociente y debe fallar. Esto signfica que un programa monádico puede fallar o no. Mientras tanto en el mundo de Coq este concepto no existe. Un programa que retorna un entero, debe retornar un entero, y más aún, un programa que tiene el tipo de una proposición, efectivamente es una prueba de la misma. Supongamos esa proposición es \lstinline{P : Prop}. Ahora para probarla monádicamente necesitamos un programa \lstinline{p : M P}, pero para cualquier \lstinline{P} podemos escribir un programa \lstinline{p} y no tener una prueba.
\begin{lstlisting}
Definition univ (P : Prop): M P :=
  raise MyException.
\end{lstlisting}

Si no utilizaramos la mónada esto no sería posible. La mónada no nos da tantas garantías como un tipo nativo de Coq.

Dada esta limitación todas las funciones nativas de Coq pueden ser utilizadas en los tipos de las funciones, pero no sucede lo mismo con las funciones monádicas. Esto hace que se tenga que pensar de manera estratégica que funciones deseamos hacer nativas y cuales monádicas.

\section{Alternativas}
% TODO: ltac2, meta-coq.
% TODO: mtac2 es shallow embedded, los otros no, los objetos de los otros son términos de un tipo inductivo Term, no tienen un tipo informativo a diferencia de los de mtac2.
% TODO: referencias https://popl19.sigplan.org/details/CoqPL-2019/8/Ltac2-Tactical-Warfare
% TODO: Mtac [9] and Mtac2 [3], Rtac [4] and Template-Coq [1], and Coq-Elpi [8].

\graffito{TODO: se necesita ojo de Beta}
\Mtac no es el único meta-lenguaje de programación para Coq. 

Un ejemplo de otro meta-lenguaje es \emph{Ltac2}.
Este funciona como un wrapper alrededor del \emph{proof engine} de Coq.
Implementa una $\alpha$ táctica de tipo monádico en OCaml y trata de conservar la mayor parte de Ltac posible, busca la mayor retrocompatibilidad.

Otras alternativas pueden ser \emph{Template-Coq} \cite{DBLP:conf/itp/AnandBCST18}, \emph{Rtac} \cite{DBLP:conf/esop/MalechaB16} y \emph{Coq-Elpi} \cite{tassi:hal-01637063}

La gran diferencia entre estos meta-lenguajes es que \Mtac es \emph{shallowly embedded}, mientras que los otros no. A diferencia de \Mtac, los objetos de estas alternativas son términos de un tipo inductivo \lstinline{Term}, es decir, no tienen un tipo informativo. Es decir, en \Mtac un programa \lstinline{M A} está garantizado que, si termina correctamente, retorna un término de tipo \lstinline{A}. Pero en los lenguajes \emph{deeply embedded} como los mencionados nada garantiza que el término retornado tenga un tipo dado; puede retornarse cualquier elemento de cualquier tipo.

\section{Telescopios}

Los \emph{telescopios} son una estructura de datos inductiva de \Mtac que permite expresar una secuencia de tipos o valores, posiblemente dependientes, y de largo arbitrario.
Los telescopios, junto con las funciones que lo acompañan, serán claves a la hora de poder expresar nuestro problema y consecuente solución.

\begin{lstlisting}[frame=tb,caption={Definicion de telescopio},label=lst:MTele]
Inductive MTele : Type :=
| mBase : MTele
| mTele {X : Type} (F : X -> MTele) : MTele.
\end{lstlisting}

\graffito{TODO: Mencionar el uso general de MTele? En ese caso cual es?}
El tipo \lstinline{MTele} crea una cadena de abstracciones.
Este se codifica a través de funciones, lo que permite que sean dependientes, es decir, un telescopio puede tener elementos que dependan de elementos anteriores.

Definiremos la siguiente notación para poder referirnos a los telescopios de una manera más accesible.

El constructor \lstinline{mBase} representa el telescopio vacío o de largo cero. Representaremos con \lstinline{[$\;$]$_t$} a \lstinline{mBase}.

Para un telescopio de largo $n$, tenemos al constructor \lstinline{mTele} anidado $n$ veces. Dado que podemos pensar al telescopio como una secuencia dependiente de tipos, un posible comienzo es \lstinline{[T$_0$ : Type ;> ...]$_t$}. Ahora, todos argumentos siguientes del telescopio pueden depender de \lstinline{T$_0$}. Luego, \lstinline{[T$_0$ : Type ;> T$_1$ : T$_0$ -> Type ;> ...]$_t$} tiene sentido, y el tipo \lstinline{T$_1$} depende de \lstinline{T$_0$}. Tranquilamente se puede dar el caso es que ningún argumento dependa de \lstinline{T$_0$}.

\begin{lstlisting}[frame=tb,caption={Notación de telescopios},label=lst:not_tele]
(* ej 1 *) mBase $\equiv$ [$\;$]$_t$
(* ej 2 *) mTele (fun T : Type => mTele R : T -> Type) $\equiv$
[T : Type ;> R : (T -> Type)]$_t$
(* ej 3 *) mTele (fun T : Type => mTele t : T) $\equiv$
[T : Type ;> t : T]$_t$
\end{lstlisting}

Para comenzar a estudiar a este tipo, podemos pensar que existen jerarquías.
La primera jerarquía sería la de los telescopios en sí, elementos de tipo \lstinline{MTele}.
Ahora, dado un \lstinline{m : MTele}, la segunda jerarquía es la de los tipos generados por el telescopio \lstinline{m}.
Luego, el último nivel es el de los elementos de este nuevo tipo telescopico.

Veremos esto en mayor profundidad, pero para eso debemos primero definir el tipo \lstinline{Sort}.

\begin{lstlisting}[frame=tb,caption={Definición de \lstinline{Sort}},label=lst:Sort]
Inductive Sort : Type := \Prop_sort | \Type_sort.
\end{lstlisting}

Dentro de unos parrafos, utilizaremos \lstinline{Sort} para abstraer el concepto de tipo y proposición, y poder aplicar ciertas funciones telescópicas.

\begin{itemize}
  \item En el nivel superior, definimos nuestro telescopio \lstinline{m} de largo $n$ con dependencias arbitrarias. Esto es simplemente utilizando los constructores de \lstinline{MTele}.
  \item Ya con \lstinline{m} definido, podemos utilizar la función \lstinline{MTele_Sort} para computar un tipo derivado del telescopio. Sea \lstinline{s : Sort}, es decir, \lstinline{s} es \lstinline{\Type_sort} o \lstinline{\Prop_sort}, la expresión \lstinline{(MTele_Sort s m)} es un tipo, y específicamente, es el tipo \lstinline{\forall x$_1$ x$_2$ ... x$_n$, s}.
  \item Como dijimos, \lstinline{(MTele_Sort s m)} es un tipo, por lo tanto, podemos tener elementos de ese tipo. Esta sería la última jerarquía.
  
  Para esto utilizamos la función \lstinline{MTele_val}. Esta función toma un valor de \lstinline{(MTele_Sort s m)} y retorna un valor de tipo \lstinline{s}. Por cómo es el tipo, esto signfica que un valor del mismo es algo de la forma \lstinline{(fun x$_1$ x$_2$ ... x$_n$ => T x$_1$ x$_2$ ... x$_n$)} para algún \lstinline{T}. Luego, \lstinline{MTele_val} retornará un valor de tipo \lstinline{s}, es decir, \lstinline{T y$_1$ y$_2$ ... y$_n$} para algunos \lstinline{y$_i$}.
\end{itemize}

Utilizaremos \lstinline{MTele_Ty} y \lstinline{MTele_Prop} para expresar \lstinline{MTele_Sort \Type_sort} y \lstinline{MTele_Sort \Prop_sort} respectivamente.

\subsection{Funciones extra}
% \graffito{TODO: falta hablar de \texttt{MTele\_C}? Sirve para definir MFA.}

Los telescopios de \Mtac traen consigo muchas funciones que son las que le dan el poder expresivo que los hace útiles. 

La función \lstinline{MTele_C} permite mapear a un \lstinline{MTele_Sort} con una función constante.
Por ejemplo, la mónada que hemos observado antes: \lstinline{M}, en realidad es una función de \lstinline{Type} en \lstinline{Prop}.
Entonces podríamos tomar un tipo \lstinline{\forall x$_1$ ... x$_n$, T x$_1$ ... x$_n$} y transformalo en \lstinline{\forall x$_1$ ... x$_n$, M (T x$_1$ ... x$_n$)}

\graffito{TODO: Ampliar, no explica nada}
Con \lstinline{MTele_In} podemos ganar acceso a múltiples tipos y valores telescopios al mismo tiempo, así siendo capaces de computar un nuevo tipo telescópico.

\subsection{Ejemplo}
% \graffito{TODO: poner ejemplos de jerarquías etc}

Para que los conceptos queden claros vamos a plantear un ejemplo de telescopios.

Primero definimos un telescopio \lstinline{m}.

\begin{lstlisting}
Definition m := [T : Type ;> l : list T ;> p : length l = 0]$_t$
\end{lstlisting}

Si ahora inspeccionamos quien es \lstinline{MTele_Sort \Type_sort m} veremos que es lo esperado.

\begin{lstlisting}
Eval cbn in MTele_Ty m.
= \forall (T : Type) (l : list T), length l = 0 -> Type : Type
\end{lstlisting}

El próximo paso es hablar de elementos de este tipo.

\begin{lstlisting}
Definition Tm : MTele_Ty m := fun T l p => l = nil.
\end{lstlisting}

Donde tenemos \lstinline{l <> nil} podemos poner cualquier tipo.
Podriamos tener \lstinline{nat}, pero para hacerlo más interesante definimos un tipo con sentido.
Lo importante es que Coq acepta la definición de \lstinline{Tm}, lo que implica que esta definición efectivamente tiene tipo el tipo esperado.
Si este no fuera el caso, el type-checker de Coq no lo aceptaría.
El próximo paso es definir un elemento del tipo \lstinline{Tm}.

Podemos definir el siguiente teorema y probarlo.

\begin{lstlisting}
Definition test_Tm : forall T (l : list T) (p : List.length l = 0), l = nil.
intros T l p. by apply length_zero_iff_nil.
Qed.
\end{lstlisting}

El truco es que al conocer a \lstinline{Tm} sabemos que esta función tiene ese tipo.
Finalmente, podemos definir lo siguiente.

\begin{lstlisting}
Definition vm : MTele_val tm := test_Tm.
\end{lstlisting}

Efectivamente, \lstinline{test_Tm} tiene tipo \lstinline{MTele_val tm}.
