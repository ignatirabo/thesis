\section{Aspectos Técnicos}

En esta sección discutiremos los aspectos técnicos de Lift. Comenzaremos discutiendo su funcionamiento básico y de ahí
escalaremos a los detalles más profundos. 

\subsection{TyTree}

En terminos generales Lift es fixpoint sobre un telescopio con un gran análisis por casos sobre los tipos.
Entonces surge un problema: ¿Cómo podemos hacer pattern matching en los tipos de manera sintáctica?
La solución es utilizar un reflejo de los mismos, de manera de que podamos expresarlos de manera inductiva.

\begin{lstlisting}
Inductive TyTree : Type :=
| tyTree_val {m : MTele} (T : MTele_Ty m) : TyTree
| tyTree_M (T : Type) : TyTree
| tyTree_MFA {m : MTele} (T : MTele_Ty m) : TyTree
| tyTree_In (s : Sort) {m : MTele} (F : accessor m -> s) : TyTree
| tyTree_imp (T : TyTree) (R : TyTree) : TyTree
| tyTree_FATele {m : MTele} (T : MTele_Ty m)
  (F : \forall t : MTele_val T, TyTree) : TyTree
| tyTree_FATele1 (m : MTele) (F : \forall (T : MTele_Ty m), TyTree) : TyTree
| tyTree_FAValue (T : Type) (F : T -> TyTree) : TyTree
| tyTree_FAType (F : Type -> TyTree) : TyTree
| tyTree_base (T : Type) : TyTree
.
\end{lstlisting}

Con este tipo podemos reescribir todas las signaturas de funciones. Varios de los constructores, como por ejemplo
\lstinline{tyTree_MFA} o \lstinline{tyTree_FATele}, tendrán sentido más adelante, dado que reflejan elementos en
funciones lifteadas.

Una de las propiedades principales de este reflejo es que a primera vista parece que un tipo puede escribirse de múltiples formas en \lstinline{TyTree}, pero los tratamos de manera distinta y por eso podemos plantear una biyección
entre \lstinline{Type} y \lstinline{TyTree}.
% TODO: Igual la función to_tree es monádica y no funciona bien.

Utilizaremos \lstinline{Const$_t$} para expresar \lstinline{tyTree_Const}, donde \lstinline{Const} representa alguno de los nombres de los constructores de la definición de \lstinline{TyTree}. 

Ahora tomaremos una función \lstinline{f} e iremos modificando si signatura para mostrar esta reflección de tipos.
Para simplificar escribiremos \lstinline{P $\equiv$ Q} para expresar que un tipo es equivalente a un \lstinline{TyTree}.

\begin{lstlisting}
f : nat -> nat -> nat
\end{lstlisting}

Su tipo traducido es

\begin{lstlisting}
f : \tyTree_imp (\tyTree_base nat) (\tyTree_imp (\tyTree_base nat) (\tyTree_base nat))
\end{lstlisting}

Dado que no hay dependencias de tipos, podemos utilizar \lstinline{\tyTree_imp}. Ahora si parametrizamos
$\nat$ por cualquier tipo.

\begin{lstlisting}
\forall A, A -> A -> A
$\equiv$
\tyTree_FAType (fun A => \tyTree_imp (\tyTree_base A) (\tyTree_imp (\tyTree_base A) (\tyTree_base A))
\end{lstlisting}

Con \lstinline{\tyTree_FAType} podemos observar claramente la dependencia de \lstinline{A}.

Para expresar la dependencia de un valor utilizamos \lstinline{\tyTree_FAValue}.

\begin{lstlisting}
\forall A (B : A -> Type) (a : A), (B a)
$\equiv$
\tyTree_FAType (fun A => \tyTree_FAType (fun B : A -> Type => \tyTree_FAValue A (fun a => \tyTree_base (B a))))
\end{lstlisting}

% TODO: dejo los otros para después? Leer comentarios de la agenda del 14 de enero.

% TODO: el tipo de lift.

% TODO: hablar de funciones lifteadas y sus tipos, es decir, TyTree's.