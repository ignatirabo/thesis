\section{Motivación}

% Se asume que se explicó que es Mtac2 en la introducción y todas las cosas que
% se pueden hacer.
\textbf{Mtac2} nos permite definir funciones monádicas. Estas cuentan con
ciertas ventajas. Un ejemplo de un meta-programa es el siguiente.

\begin{lstlisting}
Definition list_max_nat :=
  mfix f (l: list nat) : l <> nil -> M nat :=
    mtmmatch l as l' return l' <> nil -> M nat with
    | [? e] [e] =m> fun nonE => M.ret e
    | [? e1 e2 l'] (e1 :: e2 :: l') =m> fun nonE =>
      let m := Nat.max e1 e2 in
      f (m :: l') cons_not_nil
    | [? l' r'] l' ++ r' => (* cualquier cosa *) 
    end.
\end{lstlisting}

Esta función calcula el máximo de una lista de números \lstinline{$\nat$ : Set}.
Dado que en el último caso del \lstinline{match} monádico analiza una expresión
con una función, y no un constructor, es imposible implementar esto sin Mtac2.

Ahora supongamos que deseamos parametrizar $\nat$ y tener una función que acepte
múltiples conjuntos. Sea
\begin{lstlisting}
Definition max (S: Set) : M (S -> S -> S) :=
  mmatch S in Set as S' return M (S' -> S' -> S') with
  | nat => M.ret Nat.max
  end.
\end{lstlisting}

la función que retorna la relación máximo en un conjunto $S$.
A primera vista nuestra idea podría fucionar.

\begin{lstlisting}
Definition list_max (S: Set)  :=
  max <- max S; (* error! *)
  mfix f (l: list S) : l' <> nil -> M S :=
    mtmmatch l as l' return l' <> nil -> M S with
    | [? e] [e] =m> fun nonE=>M.ret e
    | [? e1 e2 l'] (e1 :: e2 :: l') =m> fun nonE =>
      m <- max e1 e2;
      f (m :: l') cons_not_nil
    end.
\end{lstlisting}

Al intentar que Coq interprete la función veremos que lstlisting no lo acepta.
Esto es debido a la signatura de \lstinline{bind}.
Nuestro \lstinline{mfix} no puede unificarse a \lstinline{M B}, ya que tiene
tipo \lstinline{f : forall (l: list S)  l' <> nil -> M S }.

\begin{lstlisting}
bind : forall A B, M A -> (A -> M B) -> M B.
\end{lstlisting}

Solucionar esta situación específica no es un problema. Una alternativa es
introducir los parámetros de la función y beta-expandir la definición del fixpoint.
Otra es codificar un nuevo bind que tenga el tipo necesario.
El problema será que este solo soluciona el problema actual, y ante cualquier
variación necesitaremos volver a solucionarlo.

Es por eso que nuestro proyecto es la codificación de un nuevo meta-programa
\lstinline{lift} que automaticamente puede generalizar meta-programas con las
dependencias necesarias para que sea utilizado en cualquier contexto.
